## zookeeper

开源分布式

### 工作机制******

![image-20250228135337578](C:\Users\陈宣玮\AppData\Roaming\Typora\typora-user-images\image-20250228135337578.png)

基于**观察者模式** 设计的分布式服务管理框架

储存和管理多组件之间都需要的数据（元数据）,接受观察者的注册

一旦数据发生变化（向节点发指令，然后向Leader上报，然后leader向全部Follower发布指令，执行之时，通知观察者，观察者根据变化的内容做出逻辑处理）

**zookeeper=文件系统+消息通知**

### 特点

- zookeeper一个领导者（leader），多个追随者（follower）组成的集群
- 集群中只要有半数节点存活，zookeeper集群就能正常服务（所以follower一般是奇数个） 
- 全局数据一致（每个follower都保存一份同样的数据副本，client无论连接到哪个Server，数据都是一致的）
- 更新请求顺序进行，来自同一个Client的更新请求按照其发送顺序依次执行
- 数据更新原子性，一次数据更新要么成功要么失败
- 实时性，在一段时间范围内，client能读到最新数据

### 数据结构

- **每个节点都有唯一路径**（类似 Linux 文件系统）。
- **ZNode 存储数据和元信息**，但不适合存大数据（一般小于 1MB）。
- **可以有子节点**，形成树形结构。

### 应用场景

唯一命名管理

可以为一定范围内的元素命名一个唯一标识，以与其它元素进行区分

统一配置管理

- 修改配置信息后快速同步各个节点（Znode）
- 将配置信息写入zookeeper上的一个节点
- 客户端监听这个Znode
- 一旦节点中数据被修改，Zookeeper通知各个客户端一起修改

同一集群管理

根据节点实时状态做出调整

<img src="C:\Users\陈宣玮\AppData\Roaming\Typora\typora-user-images\image-20250301110511355.png" alt="image-20250301110511355" style="zoom: 67%;" />

service监听orderService（最新的数据）根据节点实时状态做出调整，【如果机器（orderService3）死掉了那么对应机器的ip也会删除掉】，以确保客户端可以及时更新访问的列表

软负载均衡

ZooKeeper本身不提供负载均衡，但可以配合客户端 **轮询、随机** 等方式,可以动态调整服务器列表，适应集群变动,实现软负载均衡。

### zookeeper原理******

#### 选举机制******

五台服务器都是最新启动没有历史数据的，

1. 第一台服务器启动发出报文未响应，状态（LOOKING）
2. 第二台服务器启动互相交换自己的选举结果，判断是否超过半数同意，未超过则1，2状态（LOOKING），超过则选举id较大的那个，由于未超过则1，2皆为（LOOKING）
3. 第三台服务器启动互相交换自己的选举结果，判断是否超过半数，已经超过半数则选举id较大的那个，则三台机器选举3号为（leader）
4. 第四台服务器启动互相交换自己的选举结果在第三台机器时超过半数，则第四台服务器只能当选follower
5. 第五台服务器同第四台一样

#### 节点类型：

持久：双端断开连接后，创建的节点不删除

短暂：双端断开连接后，创建的临时节点会删除

顺序号：创建znode时是指顺序标识，znode名称附加一个值，顺序号是一个单调递增的计数器，由父节点维护，顺序号可以用作所有事情进行全局排序，客户端可以以此推断事情的顺序

#### STAT结构体

zookeeper中具体储存了哪些信息

Zxid可以用于记录Zookeeper中的状态改变，包括节点的增删改查等操作。通过Zxid，可以确定某个时间点系统所处的状态。

time是时间戳从1970年开始

pZxid是最后更新的子节点zxid

cversion是znode子节点变化号和子节点修改次数

datalenght是znode的数据长度

numChildren是znode的子节点数（不包括孙子辈）

#### 监听器原理******

1. 启动main线程
2. 创建一个zkClient 同时创建一个connect连接线程和listener监听线程
3. 连接线程连接zk集群的某个数据节点，记录（谁链接连接哪个节点）
4. 将注册信息放到监听器列表
5. 数据变化时，zk会发现数据更改，并且通知listener
6. listener接收后，将逻辑写入process()方法，只要数据一变化，就执行process()方法

#### 写数据流程******

客户端选择一个zkServer节点写入数据

如果这个节点不是leader，就把请求转发给leader

leader广播写入信息，让所有follower节点都写入数据

当leader收到（半数以上）follower都写入成功后就代表成功  

leader告诉节点写入成功，节点告诉客户端写入成功

#### zookeeper集群中的角色：

leader，follower，Observer（10个节点以上采用，提高性能）

#### 与其他分布式协同组件相比

zookeeper是服务与大数据的，支持的ZAB协议，一种原子广播的**一致性**协议，整体遵循cp原则

Nacos专为微服务和云原生设计提供服务治理功能，使用RAFT协议遵循（AP或者CP）具有强一致性

#### CAP

C：一致性

A：可用性

P：分区容错（分布式）

CA：一个机器

CP:一致性+分区（）

AP：可用性+分区（一台机器故障可以用其他的替代）		

### 客户端相关操作

启动客户端

```
bin/zkCli.sh
```



### api
